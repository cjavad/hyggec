// hyggec - The didactic compiler for the Hygge programming language.
// Copyright (C) 2023 Technical University of Denmark
// Author: Alceste Scalas <alcsc@dtu.dk>
// Released under the MIT license (see LICENSE.md for details)

/// Transformation of a program AST into Administrative Normal Form.
module ANF

open AST


/// ANF definition: a variable name with a boolean mutability boolean flag, and
/// the AST node (expected to be in ANF) that initialises the variable.
type internal ANFDef<'E,'T>(var: string, isMutable: bool, init: Node<'E,'T>) =
    /// Variable introduced by this ANF definition.
    member this.Var = var
    /// Is this ANF definition introducing a mutable variable?
    member this.IsMutable = isMutable
    /// Initialisation expression (in ANF) of this ANF definition.
    member this.Init = init

    /// Construct an ANF definition with an autogenerated unique variable name.
    new(isMutable: bool, init: Node<'E,'T>) =
        ANFDef(Util.genSymbol "$anf", isMutable, init)


/// List of ANF definitions.
type internal ANFDefs<'E,'T> = List<ANFDef<'E,'T>>


/// Utility function to generate a unique variable name for binding ANF
/// definitions.
let internal anfVar() = Util.genSymbol "$anf"


/// Given the AST 'node', return a new AST node where every free occurrence of
/// the variable called 'var' is substituted by variable 'var2'.
let rec substVar (node: Node<'E,'T>) (var: string) (var2: string): Node<'E,'T> =
    match node.Expr with
    | UnitVal
    | IntVal(_)
    | BoolVal(_)
    | FloatVal(_)
    | StringVal(_) -> node // The substitution has no effect

    | Pointer(_) -> node // The substitution has no effect

    | Var(vname) when vname = var -> {node with Expr = Var(var2)} // Substitution applied
    | Var(_) -> node // The substitution has no effect
    
    | Sub(lhs, rhs) ->
        {node with Expr = Sub((substVar lhs var var2), (substVar rhs var var2))} 
    | Add(lhs, rhs) ->
        {node with Expr = Add((substVar lhs var var2), (substVar rhs var var2))}
    | Mult(lhs, rhs) ->
        {node with Expr = Mult((substVar lhs var var2), (substVar rhs var var2))}
    | Div(lhs, rhs) ->
        {node with Expr = Div((substVar lhs var var2), (substVar rhs var var2))}
    | Rem(lhs, rhs) ->
        {node with Expr = Rem((substVar lhs var var2), (substVar rhs var var2))}
    | AddAssign(lhs, rhs) ->
        {node with Expr = AddAssign((substVar lhs var var2), (substVar rhs var var2))}
    | SubAssign(lhs, rhs) ->
        {node with Expr = SubAssign((substVar lhs var var2), (substVar rhs var var2))}
    | MultAssign(lhs, rhs) ->
        {node with Expr = MultAssign((substVar lhs var var2), (substVar rhs var var2))}
    | DivAssign(lhs, rhs) ->
        {node with Expr = DivAssign((substVar lhs var var2), (substVar rhs var var2))}
    | RemAssign(lhs, rhs) ->
        {node with Expr = RemAssign((substVar lhs var var2), (substVar rhs var var2))}
    | And(lhs, rhs) ->
        {node with Expr = And((substVar lhs var var2), (substVar rhs var var2))}
    | ScAnd(lhs, rhs) ->
        {node with Expr = ScAnd((substVar lhs var var2), (substVar rhs var var2))}
    | Or(lhs, rhs) ->
        {node with Expr = Or((substVar lhs var var2), (substVar rhs var var2))}
    | BNot(arg) ->
        {node with Expr = BNot(substVar arg var var2)}
    | BAnd(lhs, rhs) ->
        {node with Expr = BAnd((substVar lhs var var2), (substVar rhs var var2))}
    | BOr(lhs, rhs) ->
        {node with Expr = BOr((substVar lhs var var2), (substVar rhs var var2))}
    | BXor(lhs, rhs) ->
        {node with Expr = BXor((substVar lhs var var2), (substVar rhs var var2))}
    | BSL(lhs, rhs) ->
        {node with Expr = BSL((substVar lhs var var2), (substVar rhs var var2))}
    | BSR(lhs, rhs) ->
        {node with Expr = BSR((substVar lhs var var2), (substVar rhs var var2))}
    | ScOr(lhs, rhs) ->
        {node with Expr = ScOr((substVar lhs var var2), (substVar rhs var var2))}
    | Xor(lhs, rhs) ->
        {node with Expr = Xor((substVar lhs var var2), (substVar rhs var var2))}
    | Sqrt(arg) ->
        {node with Expr = Sqrt(substVar arg var var2)}
    | Not(arg) ->
        {node with Expr = Not(substVar arg var var2)}
    | Neg(arg) ->
        {node with Expr = Neg(substVar arg var var2)}
    | Eq(lhs, rhs) ->
        {node with Expr = Eq((substVar lhs var var2), (substVar rhs var var2))}
    | Less(lhs, rhs) ->
        {node with Expr = Less((substVar lhs var var2), (substVar rhs var var2))}
    | LessEq(lhs, rhs) ->
        {node with Expr = Less((substVar lhs var var2), (substVar rhs var var2))}
    | Greater(lhs, rhs) ->
        {node with Expr = Less((substVar lhs var var2), (substVar rhs var var2))}
    | GreaterEq(lhs, rhs) ->
        {node with Expr = Less((substVar lhs var var2), (substVar rhs var var2))}

    | ReadInt
    | ReadFloat -> node // The substitution has no effect
    // add later
    | Postinc(arg) -> failwith"Implement increment"
    | Preinc(arg) -> failwith"Implement increment"
    | Print(arg) ->
        {node with Expr = Print(substVar arg var var2)}
    | PrintLn(arg) ->
        {node with Expr = PrintLn(substVar arg var var2)}
    | Syscall(num, args) ->
        let substArgs = List.map (fun n -> (substVar n var var2)) args
        {node with Expr = Syscall(num, substArgs)}
    | If(cond, ifTrue, ifFalse) ->
        {node with Expr = If((substVar cond var var2), (substVar ifTrue var var2),
                                                       (substVar ifFalse var var2))}
   
    | Seq(nodes) ->
        let substNodes = List.map (fun n -> (substVar n var var2)) nodes
        {node with Expr = Seq(substNodes)}

    | Ascription(tpe, node) ->
        {node with Expr = Ascription(tpe, (substVar node var var2))}

    | Let(vname, init, scope) when vname = var ->
        // Do not substitute the variable in the "let" scope
        {node with Expr = Let(vname,(substVar init var var2), scope)}
    | Let(vname, init, scope) ->
        {node with Expr = Let(vname, (substVar init var var2),
                              (substVar scope var var2))}

    | LetT(vname, tpe, init, scope) when vname = var ->
        // Do not substitute the variable in the "let" scope
        {node with Expr = LetT(vname, tpe, (substVar init var var2), scope)}
    | LetT(vname, tpe, init, scope) ->
        {node with Expr = LetT(vname, tpe, (substVar init var var2),
                               (substVar scope var var2))}

    | LetMut(vname, init, scope) when vname = var ->
        // Do not substitute the variable in the "let mutable" scope
        {node with Expr = LetMut(vname, (substVar init var var2), scope)}
    | LetMut(vname, init, scope) ->
        {node with Expr = LetMut(vname, (substVar init var var2),
                                 (substVar scope var var2))}

    | Assign(target, expr) ->
        {node with Expr = Assign((substVar target var var2), (substVar expr var var2))}

    | While(cond, body) ->
        let substCond = substVar cond var var2
        let substBody = substVar body var var2
        {node with Expr = While(substCond, substBody)}

    | For(ident, init, cond, step, body) ->
        let substCond = substVar cond var var2
        let substBody = substVar body var var2
        let substInit = substVar init var var2
        let substStep = substVar init var var2
        {node with Expr = For(ident, substInit, substCond, substStep, substBody)}

    | Assertion(arg) ->
        {node with Expr = Assertion(substVar arg var var2)}

    | Type(tname, def, scope) ->
        {node with Expr = Type(tname, def, (substVar scope var var2))}

    | Lambda(args, body) ->
        /// Arguments of this lambda term, without their pretypes
        let (argVars, _) = List.unzip args
        if (List.contains var argVars) then node // No substitution
        else {node with Expr = Lambda(args, (substVar body var var2))}

    | Application(expr, args) ->
        let substExpr = substVar expr var var2
        let substArgs = List.map (fun n -> (substVar n var var2)) args
        {node with Expr = Application(substExpr, substArgs)}

    | StructCons(fields) ->
        let (fieldMutables, fieldNames, initNodes) = List.unzip3 fields
        let substInitNodes = List.map (fun e -> (substVar e var var2)) initNodes
        {node with Expr = StructCons(List.zip3 fieldMutables fieldNames substInitNodes)}

    | FieldSelect(target, field) ->
        {node with Expr = FieldSelect((substVar target var var2), field)}

    | UnionCons(label, expr) ->
        {node with Expr = UnionCons(label, (substVar expr var var2))}

    | Match(expr, cases) ->
        /// Mapper function to propagate the substitution along a match case
        let substCase(lab: string, v: string, cont: Node<'E,'T>) =
            if (v = var) then (lab, v, cont) // Variable bound, no substitution
            else (lab, v, (substVar cont var var2))
        let cases2 = List.map substCase cases
        {node with Expr = Match((substVar expr var var2), cases2)}
    
    | ArrayElem(target, index) -> failwith "Not done"
    | ArrayLength(target) -> failwith "Not done"
    | Array(length, data) -> failwith "Not done"
    


/// Convert a given AST node (expected to contain a variable) and a list of ANF
/// definitions (with the most recent at the head of the list) into a
/// corresponding series nested of "let" binders in ANF, having the given AST
/// node in the innermost scope.
let rec internal toANF (node: Node<'E,'T>, defs: ANFDefs<'E,'T>): Node<'E,'T> =
    match defs with
    | [] -> node
    | anfDef :: rest ->
        /// Binder for this ANF definition
        let binder = if anfDef.IsMutable then
                         LetMut(anfDef.Var, anfDef.Init, node)
                     else
                         Let(anfDef.Var, anfDef.Init, node)
        toANF ({node with Expr = binder}, rest)


/// Transform the given AST node into a variable, plus a list of ANF definitions
/// --- i.e. the variable names with their definitions (also in ANF) that are
/// required to compute the returned variable. NOTE: the list of definitions is
/// constructed in reverse, with the most recent addition at the front (to
/// improve performance).
let rec internal toANFDefs (node: Node<'E,'T>): Node<'E,'T> * ANFDefs<'E,'T> =
    match node.Expr with
    | UnitVal
    | BoolVal(_)
    | IntVal(_)
    | FloatVal(_)
    | StringVal(_) as expr ->
        /// Definition binding this value to a variable
        let anfDef = ANFDef(false, {node with Expr = expr})
        ({node with Expr = Var(anfDef.Var)}, [anfDef])

    | Var(_) ->
        (node, []) // This AST node is already in ANF

    | BAnd(lhs, rhs)
    | BOr(lhs, rhs)
    | BXor(lhs, rhs)
    | BSL(lhs, rhs)
    | BSR(lhs, rhs)
    | Sub(lhs, rhs)
    | Add(lhs, rhs)
    | Mult(lhs, rhs)
    | Div(lhs, rhs)
    | Rem(lhs, rhs)
    | And(lhs, rhs)
    | ScAnd(lhs, rhs)
    | Or(lhs, rhs)
    | ScOr(lhs, rhs)
    | Xor(lhs, rhs)
    | Eq(lhs, rhs)
    | Greater(lhs, rhs)
    | LessEq(lhs, rhs)
    | GreaterEq(lhs, rhs)
    | Less(lhs, rhs) as expr ->
        /// Left-hand-side argument in ANF and related definitions
        let (lhsANF, lhsDefs) = toANFDefs lhs
        /// Right-hand-side argument in ANF and related definitions
        let (rhsANF, rhsDefs) = toANFDefs rhs
        /// This expression in ANF
        let anfExpr = match expr with
                      | BAnd(_,_) -> BAnd(lhsANF, rhsANF)
                      | BOr(_,_) -> BOr(lhsANF, rhsANF)
                      | BXor(_,_) -> BXor(lhsANF, rhsANF)
                      | BSL(_,_) -> BSL(lhsANF, rhsANF)
                      | BSR(_,_) -> BSR(lhsANF, rhsANF)
                      | Sub(_,_) -> Sub(lhsANF, rhsANF)
                      | Add(_,_) -> Add(lhsANF, rhsANF)
                      | Mult(_,_) -> Mult(lhsANF, rhsANF)
                      | And(_,_) -> And(lhsANF, rhsANF)
                      | ScAnd(_,_) -> ScAnd(lhsANF, rhsANF)
                      | Or(_,_) -> Or(lhsANF, rhsANF)
                      | ScOr(_,_) -> ScOr(lhsANF, rhsANF)
                      | Xor(_,_) -> Xor(lhsANF, rhsANF)
                      | Eq(_,_) -> Eq(lhsANF, rhsANF)
                      | Greater(_,_) -> Greater(lhsANF, rhsANF)
                      | LessEq(_,_) -> LessEq(lhsANF, rhsANF)
                      | GreaterEq(_,_) -> GreaterEq(lhsANF, rhsANF)
                      | Less(_,_) -> Less(lhsANF, rhsANF)
                      | e -> failwith $"BUG: unexpected expression: %O{e}"
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = anfExpr})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: (rhsDefs @ lhsDefs))

    | ReadInt
    | ReadFloat as expr ->
        /// Definition binding this expression to a variable
        let anfDef = ANFDef(false, {node with Expr = expr})
        ({node with Expr = Var(anfDef.Var)}, [anfDef])

    | BNot(arg)
    | Not(arg)
    | Sqrt(arg)
    | Neg(arg)
    | Print(arg)
    | PrintLn(arg)
    | Assertion(arg) as expr ->
        /// Argument in ANF and related definitions
        let (argANF, argDefs) = toANFDefs arg
        /// This expression in ANF
        let anfExpr = match expr with
                      | BNot(_) -> BNot(argANF)
                      | Sqrt(_) -> Sqrt(argANF)
                      | Not(_) -> Not(argANF)
                      | Neg(_) -> Neg(argANF)
                      | Print(_) -> Print(argANF)
                      | PrintLn(_) -> PrintLn(argANF)
                      | Assertion(_)  -> Assertion(argANF)
                      | e -> failwith $"BUG: unexpected expression: %O{e}"
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = anfExpr})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: argDefs)
    | Syscall(num, args) ->
        /// Arguments in ANF and related definitions
        let (argsANF, argsDefs) = List.unzip (List.map toANFDefs args)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Syscall(num, argsANF)})

        ({node with Expr = Var(anfDef.Var)},
         anfDef :: List.concat (List.rev argsDefs))
    | Seq(nodes) ->
        match (List.rev nodes) with
        | [] ->
            failwith $"BUG: empty AST Seq node at %O{node.Pos}"
        | last :: rest ->
            /// Last AST node in the sequence in ANF and related definitions
            let (lastANF, lastDefs) = toANFDefs last
            /// ANF definitions of the rest of the Seq nodes (in reverse order).
            /// We collect the definitions and ignore the variable bound to each
            /// node of the sequence, because such variable will be unused in
            /// the sequence.
            let restANFDefs = List.collect snd (List.map toANFDefs rest)

            (lastANF, lastDefs @ restANFDefs)

    | Ascription(tpe, arg) ->
        /// Argument in ANF and related definitions
        let (argANF, argDefs) = toANFDefs arg
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Ascription(tpe, argANF)})
        ({node with Expr = Var(anfDef.Var)}, anfDef :: argDefs)
    
    | Postinc(arg) -> failwith"Implement increment"
    | Preinc(arg) -> failwith"Implement increment"
    | Array(length, data) -> failwith"Implement array"
    | ArrayElem(target, index) -> failwith"Implement array"
    | ArrayLength(target) -> failwith"Implement array"
    
    | If(condition, ifTrue, ifFalse) ->
        /// Condition in ANF and related definitions
        let (condANF, condDefs) = toANFDefs condition
        /// True branch in ANF
        let ifTrueANF = toANF (toANFDefs ifTrue)
        /// True branch in ANF
        let ifFalseANF = toANF (toANFDefs ifFalse)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = If(condANF, ifTrueANF, ifFalseANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: condDefs)

    | Let(name, init, scope)
    | LetT(name, _, init, scope)
    | LetMut(name, init, scope) as expr ->
        // ANF requires variable names to be unique, so we rewrite the scope
        /// Variable name bound by this 'let' expression, made unique
        let uniqName = Util.genSymbol name
        /// Rewritten scope with 'name' replaced by 'uniqName'
        let scope = substVar scope name uniqName
        /// Variable name (now made unique) bound by this 'let' expression
        let name = uniqName
        /// Initialization expression in ANF and related definitions
        let (initANF, initDefs) = match init.Expr with
                                  | UnitVal
                                  | BoolVal(_)
                                  | IntVal(_)
                                  | FloatVal(_)
                                  | StringVal(_)
                                  | Var(_) ->
                                      (init, []) // 'init' is already in ANF
                                  | _ ->
                                      toANFDefs init
        /// Scope expression in ANF and its related definitions
        let (scopeANF, scopeDefs)  = toANFDefs scope
        /// Is this a mutable "let"?
        let isMutable = match expr with
                        | Let(_,_,_)
                        | LetT(_,_,_,_) -> false
                        | LetMut(_,_,_) -> true
                        | e -> failwith $"BUG: unexpected expression: %O{e}"
        /// Definition binding the "let" variable to the init expression in ANF
        let letDef = ANFDef(name, isMutable, initANF)

        ({node with Expr = scopeANF.Expr}, scopeDefs @ letDef :: initDefs)

    | Assign(target, asgnExpr)
    | AddAssign(target, asgnExpr)
    | SubAssign(target, asgnExpr)
    | MultAssign(target, asgnExpr)
    | DivAssign(target, asgnExpr)
    | RemAssign(target, asgnExpr) ->
        let asgnExpr = 
            match node.Expr with
            | AddAssign(_, _) -> {asgnExpr with Expr = Add(target, asgnExpr)}
            | SubAssign(_, _) -> {asgnExpr with Expr = Sub(target, asgnExpr)}
            | MultAssign(_, _) -> {asgnExpr with Expr = Mult(target, asgnExpr)}
            | DivAssign(_, _) -> {asgnExpr with Expr = Div(target, asgnExpr)}
            | RemAssign(_, _) -> {asgnExpr with Expr = Rem(target, asgnExpr)}
            | _ -> asgnExpr

        /// Source expression of the assignment in ANF and related definitions
        let asgnExprANF, asgnExprDefs = toANFDefs asgnExpr
        match target.Expr with
        | Var _ ->
            /// Definition binding this expression in ANF to its variable
            let anfDef = ANFDef(false, {node with Expr = Assign(target, asgnExprANF)})
            {node with Expr = Var anfDef.Var}, anfDef :: asgnExprDefs
        | FieldSelect(ftarget, field) ->
            /// Target expr of the field selection in ANF and related definitions
            let ftargetExprANF, ftargetExprDefs = toANFDefs ftarget
            /// Assignment to field selection in ANF form
            let anfAssign = Assign({target with Expr = FieldSelect(ftargetExprANF, field)}, asgnExprANF)
            /// Definition binding this expression in ANF to its variable
            let anfDef = ANFDef(false, {node with Expr = anfAssign})
            {node with Expr = Var anfDef.Var}, anfDef :: (ftargetExprDefs @ asgnExprDefs)
        | _ ->
            failwith $"BUG: invalid assignment target: %O{target}"

    | While(cond, body) ->
        /// Condition expression in ANF and related definitions
        let condANF = toANF (toANFDefs cond)
        /// Body of the 'while' loop in ANF
        let bodyANF = toANF (toANFDefs body)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = While(condANF, bodyANF)})

        ({node with Expr = Var(anfDef.Var)}, [anfDef])

    | For(ident, init, cond, step, body) ->
        /// Condition expression in ANF and related definitions
        let condANF = toANF (toANFDefs cond)
        /// Body of the 'while' loop in ANF
        let bodyANF = toANF (toANFDefs body)

        let initANF = toANF (toANFDefs init)

        let stepANF = toANF (toANFDefs step)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = For(ident, initANF, condANF, stepANF, bodyANF)})

        ({node with Expr = Var(anfDef.Var)}, [anfDef])
    
    | Type(name, def, scope) ->
        /// Scope expression in ANF
        let scopeANF = toANF (toANFDefs scope)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Type(name, def, scopeANF)})

        ({node with Expr = Var(anfDef.Var)}, [anfDef])

    | Lambda(args, body) ->
        // ANF requires variable names to be unique, so we rewrite the body
        /// Variable names bound by the lambda term, and their types
        let (argNames, argTypes) = List.unzip args
        /// Variable names bound by the lambda term, made unique
        let uniqArgNames = List.map Util.genSymbol argNames
        /// Rewritten lambda term body with renamed variables
        let uniqVarsBody = List.fold (fun body (v, v2) -> substVar body v v2)
                                     body (List.zip argNames uniqArgNames)
        /// Lambda term body in ANF
        let bodyANF = toANF (toANFDefs uniqVarsBody)
        /// Unique lambda term argument names and respective types
        let uniqArgs = List.zip uniqArgNames argTypes

        ({node with Expr = Lambda(uniqArgs, bodyANF)}, [])
    
    | Application(appExpr, args) ->
        /// Applied expression in ANF and related definitions
        let (appExprANF, appExprDefs) = toANFDefs appExpr
        /// Application arguments in ANF and related definitions
        let (argsANF, argsDefs) = List.unzip (List.map toANFDefs args)
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Application(appExprANF, argsANF)})

        // Remember: the ANF definitions are ordered with the most recent first
        ({node with Expr = Var(anfDef.Var)},
         anfDef :: List.concat (List.rev argsDefs) @ appExprDefs)

    | StructCons(fields) ->
        let (fieldMutables, fieldNames, fieldNodes) = List.unzip3 fields
        /// Struct fields in ANF and related definitions
        let (fieldsANF, fieldsDefs) = List.unzip (List.map toANFDefs fieldNodes)
        /// Updated structure fields (names and nodes) in ANF
        let fields2 = List.zip3 fieldMutables fieldNames fieldsANF
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = StructCons(fields2)})

        // Remember: the ANF definitions are ordered with the most recent first
        ({node with Expr = Var(anfDef.Var)},
         anfDef :: List.concat (List.rev fieldsDefs))

    | FieldSelect(target, field) ->
        /// Target expression in ANF and related definitions
        let (targetANF, targetDefs) = toANFDefs target
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = FieldSelect(targetANF, field)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: targetDefs)

    | Pointer(_) ->
        failwith "BUG: pointers cannot be converted to ANF (by design!)"

    | UnionCons(label, init) ->
        /// Union initialization expression in ANF and related definitions
        let (initANF, initDefs) = toANFDefs init
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = UnionCons(label, initANF)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: initDefs)

    | Match(matchExpr, cases) ->
        /// Matched expression in ANF and related definitions
        let (matchExprANF, matchExprDefs) = toANFDefs matchExpr
        let (casesLabels, casesVars, casesConts) = List.unzip3 cases
        // ANF requires unique var names, so we rewrite the match continuations
        /// Match case variables, made unique
        let uniqCasesVars = List.map Util.genSymbol casesVars
        /// Rewritten match continuations, using the unique variables
        let uniqCasesConts = List.map (fun (c, v, v2) -> substVar c v v2)
                                      (List.zip3 casesConts casesVars uniqCasesVars)
        /// Match cases continuations in ANF
        let casesContsANF = List.map (fun n -> toANF (toANFDefs n))
                                     uniqCasesConts
        /// Updated match cases with continuations in ANF
        let cases2 = List.zip3 casesLabels uniqCasesVars casesContsANF
        /// Definition binding this expression in ANF to its variable
        let anfDef = ANFDef(false, {node with Expr = Match(matchExprANF, cases2)})

        ({node with Expr = Var(anfDef.Var)}, anfDef :: matchExprDefs)


/// Transform the given AST node into Administrative Normal Form.
let transform (ast: Node<'E,'T>): Node<'E,'T> =
    toANF (toANFDefs ast)
